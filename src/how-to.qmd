---
title: "How To"
format: html
editor: source
editor_options: 
  chunk_output_type: console
---

## Dependencies

To work with NETCDF data in R, you'll need the `stars` and `sf` packages. We'll also use `dplyr` (from the tidyverse) for data wrangling and `ggplot2` for visuals. Additionally, the `lubridate` package makes working with dates easier, while `here` takes care of relative file paths.

Dependencies are defined using two commands: `install.packages` and `library`

```{r}
#| include: false
if (!"stars" %in% installed.packages()) install.packages("stars")
library(stars)
```

We'll make this easier by using `pacman`, which will do all of that as once for as many packages as we like.

```{r}
#| include: false
if (!"pacman" %in% installed.packages()) install.packages("pacman")
pacman::p_load(stars, 
               sf, 
               dplyr, 
               ggplot2, 
               lubridate, 
               here)
```


## Reading NETCDF files

The `stars` and `sf` packages provide a simple interface to work with high-dimensional geographical data.

First, we'll read data from both scenarios.

```{r}
#| include: false

rcp45 <- read_stars(here("src/data/raw/suitability/suitability_rcp45.nc"))
rcp85 <- read_stars(here("src/data/raw/suitability/suitability_rcp85.nc"))
```

Then, we'll combine them into one single object

```{r}
sims <- c("rcp45" = rcp45, "rcp85" = rcp85, along = "scenario")
```

...with an additional dimension `scenario` to be able to filter later on.

A `stars` object is a high-dimensional raster object - a "data cube", to quote the package author. When printing it to the console, we can see that our data consists of 5 variables: SUIT_E to SUIT_L, each one a suitability index for early (SUIT_E) up until late (SUIT_L) varieties, ranging from 0 to 1. We also see that the object contains 4 dimensions: `LON` and `LAT` for grid cell centroids, a timestamp for each year from 1980 to 2099, and our `scenario` variable. 

```{r}
sims
```


## Working with data cubes

When dealing with a data cube, you can either manipulate it directly or first extract a slice, convert it to a lower-dimensional data frame (a simple-features tibble, to be precise) and then decide where to go next. Usually, you'll want to go for the second, much simpler option.

```{r}
sims %>% 
  filter(year(TIME) == 2024,
         scenario == "rcp45") %>% 
  st_as_sf()
```

You could also extract data for multiple years or scenarios:

```{r}
sims %>% 
  filter(year(TIME) %in% c(2024, 2099)) %>% 
  st_as_sf()
```

But since the algorithm needs to merge your slice into a two-dimensional data frame, you'll end up with lots of numbered columns. To avoid this, set `long = TRUE`. The result is a data frame in long format with additional columns to identify each individual data point.

```{r}
sims %>% 
  filter(year(TIME) %in% c(2024, 2099)) %>% 
  st_as_sf(long = TRUE)
```

Our dataset contains predictions for grid cells all over europe. Let's extract only values for grid cells within Germany. We'll do this in three steps. First, we crop our `stars` object to the bounding box of Germany. Then we grab all data points for the year 2024 within a RCP4.5-scenario and reduce the dimensions, just as before. Lastly, we "cut out" the correct shape.

Let's load a polygon of Germany

```{r}
#| include: false

germany <- read_sf(here("src/data/raw/vg2500_12-31.gk3.shape/vg2500/VG2500_STA.shp")) %>% 
  filter(GF == 9) %>% 
  st_transform(4326) %>% 
  select(geometry)
```

...and use it:

```{r}
#| include: false

my_slice <- sims %>% 
  st_crop(germany) %>% # crops to bounding box
  filter(year(TIME) == 2024,
         scenario == "rcp45") %>% 
  st_as_sf() %>% 
  # creates intersection of both geometries, effectively dropping grid cells 
  # outside of Germany and reshaping those at the border
  st_intersection(germany) 
```


## Plotting geodata

Let's take a look at the result. We'll pass it to `ggplot` and use `geom_sf` to plot all grid cells.

```{r}
my_slice %>% 
  ggplot() +
  geom_sf()
```

Easy! Just remember that `ggplot` uses `+` instead of `%>%` for historical reasons. 

Now let's add some color. Where is the climate suitable for early wine variations?

```{r}
my_slice %>% 
  ggplot() +
  geom_sf(aes(fill = SUIT_E))
```

Let's get rid of the gridlines. Normally, you would do this by setting `color = NA` or `lwd = 0` within `geom_sf` - but this does not work, it's a known bug. Instead, set color to use the same variable as fill:

```{r}
my_slice %>% 
  ggplot() +
  geom_sf(aes(fill = SUIT_E, color = SUIT_E))
```

Let's add some styles:

```{r}
my_slice %>% 
  ggplot() +
  geom_sf(aes(fill = SUIT_E, color = SUIT_E)) +
  scale_fill_continuous(limits = c(0, 1)) +
  scale_color_continuous(limits = c(0, 1)) +
  labs(title = "Suitability für frühe Weine im Jahr 2024",
       fill = NULL,
       color = NULL) +
  theme_void()
  
```




















